/*
Copyright (c) 2014-2021 Martin Cejp

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Binary I/O stream interfaces
 *
 * Copyright: Martin Cejp 2014-2021.
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Martin Cejp, Timur Gafarov
 */
module dlib.core.stream;

import std.bitmanip;
import std.stdint;
import std.conv;

import dlib.core.memory;

alias StreamPos = uint64_t;
alias StreamSize = uint64_t;
alias StreamOffset = int64_t;

/// An exception which is throwed on stream errors
class SeekException : Exception
{
    this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)
    {
        super(msg, file, line, next);
    }
}

/**
 * Seekable stream interface
 *
 * Description:
 * Represents a stream container that knows the size of a stream 
 * and allows to change byte position within the stream.
 */
interface Seekable
{
    /// Returns current position
    StreamPos getPosition() @property;
    
    /**
     * Attempts to set current position to pos.
     * Returns true on success, false on failure
     */
    bool setPosition(StreamPos pos);
    
    /// Returns the size of a stream in bytes
    StreamSize size();

    /**
     * Attempts to set current position to pos.
     * Throws SeekException on failure
     */
    final StreamPos position(StreamPos pos)
    {
        if (!setPosition(pos))
            throw new SeekException("Cannot set Seekable position to " ~ pos.to!string);
        return pos;
    }

    /// ditto
    final StreamPos position()
    {
        return getPosition();
    }

    /**
     * Relatively changes position.
     * amount defines an offset from the current position (can be negative).
     * Throws SeekException on failure
     */
    final StreamPos seek(StreamOffset amount)
    {
        immutable StreamPos seekTo = getPosition() + amount;

        if (!setPosition(seekTo))
            throw new SeekException("Cannot set Seekable position to " ~ seekTo.to!string);

        return seekTo;
    }
}

/**
 * A parent interface for all stream types
 */
interface Stream: Seekable
{
    /// Closes the stream. Closed stream cannot be read or written any more
    void close();
    
    /// Returns true if it is legal to use Seekable functionality on this stream
    bool seekable();
}

/**
 * A stream inteface that allows to read data from it.
 * Reading any data implies position advance by corresponding number of bytes.
 * Methods shouldn't throw on EOF, may throw on a more serious error
 */
interface InputStream: Stream
{
    /// Returns true if there are any data to read. false means end of the stream.
    bool readable();
    
    /**
     * Attempts to read count bytes from stream and stores them in memory 
     * pointing by buffer. Returns number of bytes actually read
     */
    size_t readBytes(void* buffer, size_t count);

    /**
     * Attempts to fill an array with raw data from stream. 
     * Returns true if the array was filled, false otherwise
     */
    final bool fillArray(T)(T[] array)
    {
        immutable size_t len = array.length * T.sizeof;
        return readBytes(array.ptr, len) == len;
    }

    /**
     * Reads little-endian integer, converts to native-endian 
     * and stores in value
     */
    final bool readLE(T)(T* value)
    {
        ubyte[T.sizeof] buffer;

        if (readBytes(buffer.ptr, buffer.length) != buffer.length)
            return false;

        *value = littleEndianToNative!T(buffer);
        return true;
    }

    /**
     * Reads big-endian integer, converts to native-endian
     * and stores in value
     */
    final bool readBE(T)(T* value)
    {
        ubyte[T.sizeof] buffer;

        if (readBytes(buffer.ptr, buffer.length) != buffer.length)
            return false;

        *value = bigEndianToNative!T(buffer);
        return true;
    }
}

/**
 * A stream interface that allows to write data into it.
 * Methods shouldn't throw on full disk, may throw on a more serious error
 */
interface OutputStream: Stream
{
    /// Implementation-specific method. Usually it writes any unwritten data from output buffer
    void flush();
    
    /// Returns true if stream can be written to, false otherwise
    bool writeable();
    
    /**
     * Attempts to write count bytes from the memory pointed by buffer. 
     * Returns number of bytes actually written
     */
    size_t writeBytes(const void* buffer, size_t count);

    /** 
     * Attempts to write an array.
     * Returns true if all elements were written, false otherwise
     */
    final bool writeArray(T)(const T[] array)
    {
        immutable size_t len = array.length * T.sizeof;
        return writeBytes(array.ptr, len) == len;
    }

    /**
     * Attempts to write a string as zero-terminated. 
     * Returns true if entire string was written, false otherwise
     */
    final bool writeStringz(string text)
    {
        ubyte[1] zero = [0];

        return writeBytes(text.ptr, text.length)
            && writeBytes(zero.ptr, zero.length);
    }

    /// Writes an integer in little-endian encoding
    final bool writeLE(T)(const T value)
    {
        ubyte[T.sizeof] buffer = nativeToLittleEndian!T(value);

        return writeBytes(buffer.ptr, buffer.length) == buffer.length;
    }

    /// Writes an integer in big-endian encoding
    final bool writeBE(T)(const T value)
    {
        ubyte[T.sizeof] buffer = nativeToBigEndian!T(value);

        return writeBytes(buffer.ptr, buffer.length) == buffer.length;
    }
}

/**
 * A stream that allows both reading and writing data
 */
interface IOStream: InputStream, OutputStream
{
}

/**
 * While input is readable, reads data from input and writes it to output. 
 * Returns number of bytes read
 */
StreamSize copyFromTo(InputStream input, OutputStream output)
{
    ubyte[0x1000] buffer;
    StreamSize total = 0;

    while (input.readable)
    {
        size_t have = input.readBytes(buffer.ptr, buffer.length);

        if (have == 0)
            break;

        output.writeBytes(buffer.ptr, have);
        total += have;
    }

    return total;
}

/**
 * An InputStream that encapsulates contents of an array
 */
class ArrayStream: InputStream
{
    // TODO: Add OutputStream methods
    
    import std.algorithm;

    /// Constructor. Initializes stream as empty
    this()
    {
    }

    /**
     * Constructor. Initializes stream with an array of bytes.
     * size delimits maximum read size
     */
    this(ubyte[] data, size_t size)
    {
        assert(size_ <= data.length);

        this.size_ = size;
        this.data = data;
    }

    /**
     * Constructor. Initializes stream with an array of bytes
     */
    this(ubyte[] data)
    {
        this(data, data.length);
    }

    override void close()
    {
        this.pos = 0;
        this.size_ = 0;
        this.data = null;
    }

    override bool readable()
    {
        return pos < size_;
    }

    override size_t readBytes(void* buffer, size_t count)
    {
        import core.stdc.string;

        count = min(count, size_ - pos);

        // whoops, memcpy out of nowhere, can we do better than that?
        memcpy(buffer, data.ptr + pos, count);

        pos += count;
        return count;
    }

    override bool seekable()
    {
        return true;
    }

    override StreamPos getPosition()
    {
        return pos;
    }

    override bool setPosition(StreamPos pos)
    {
        if (pos > size_)
            return false;

        this.pos = cast(size_t)pos;
        return true;
    }

    override StreamSize size()
    {
        return size_;
    }

    private:
    size_t pos = 0, size_ = 0;
    ubyte[] data;       // data.length is capacity
}

///
unittest
{
    ubyte[] arr = [23,13,42,71,0,1,1,2,3,5,8];

    auto stream = new ArrayStream(arr);
    assert(stream.size() == arr.length);

    ubyte[4] buf;
    assert(stream.readBytes(buf.ptr, buf.length) == buf.length);
    assert(buf == [23,13,42,71]);
    assert(stream.getPosition() == buf.length);

    assert(stream.setPosition(6));
    assert(stream.getPosition == 6);
    assert(stream.readBytes(buf.ptr, buf.length) == buf.length);
    assert(buf == [1,2,3,5]);

    assert(stream.readBytes(buf.ptr, buf.length) == 1);
    assert(buf[0] == 8);
    assert(!stream.readable);

    stream.setPosition(1);
    assert(stream.readable);
    stream.seek(4);
    assert(stream.readBytes(buf.ptr, buf.length) == buf.length);
    assert(buf == [1,1,2,3]);

    assert(stream.setPosition(arr.length));
    assert(!stream.setPosition(arr.length+1));

    stream.close();
    assert(!stream.readable);
}

/**
 * An input range that reads data from InputStream by fixed chunks, 
 * storing them in user-provided array
 */
struct BufferedStreamReader
{
    InputStream stream;
    ubyte[] buffer;
    ubyte[] front;
    
    /// Constructor. Initializes range with a stream and a buffer
    this(InputStream istrm, ubyte[] buffer)
    {
        stream = istrm;
        this.buffer = buffer;
        popFront();
    }
    
    bool empty = false;
    
    void popFront()
    {
        empty = !stream.readable();
        size_t readLen = stream.readBytes(buffer.ptr, buffer.length);
        if (readLen > 0)
            front = buffer[0..readLen];
    }
}
