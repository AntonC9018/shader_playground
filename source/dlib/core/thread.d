/*
Copyright (c) 2015-2021 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/**
 * Cross-platform thread class. Supports Windows and Posix
 *
 * Description:
 * This module provides a platform-independent multithreading API.
 * For now, it supports Windows and Posix threads (pthreads). The interface
 * is greatly inspired by core.thread from Phobos, but dlib.core.thread
 * is fully GC-free and can be used with dlib.core.memory allocators.
 *
 * Implementation notes:
 *
 * - No TLS support, sorry. Any global variables should be marked with
 *   __gshared for correct access from threads.
 *
 * - Internals of Thread class are platform-dependent, so be aware of that
 *   when inheriting.
 *
 * Copyright: Timur Gafarov 2015-2021.
 * License: $(LINK2 https://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Timur Gafarov
 */
module dlib.core.thread;

version(Windows)
{
    extern(Windows):

    struct SECURITY_ATTRIBUTES
    {
        uint   nLength;
        void*  lpSecurityDescriptor;
        int    bInheritHandle;
    }

    alias LPTHREAD_START_ROUTINE = extern(Windows) uint function(in void*);

    void* CreateThread(
        in SECURITY_ATTRIBUTES*   lpThreadAttributes,
        in size_t                 dwStackSize,
        in LPTHREAD_START_ROUTINE lpStartAddress,
        in void*                  lpParameter,
        in uint                   dwCreationFlags,
        uint*                     lpThreadId
    );

    uint WaitForMultipleObjects(
        in uint nCount,
        in void** lpHandles,
        in int bWaitAll,
        in uint dwMilliseconds
    );

    int TerminateThread(
        void* hThread,
        in uint dwExitCode
    );

    int GetExitCodeThread(
        in void* hThread,
        uint* lpExitCode
    );

    int CloseHandle(
        in void* hObject
    );

    enum INFINITE = uint.max;
    enum STILL_ACTIVE = 259;
}

version(Posix)
{
    import core.sys.posix.pthread;
}

version(Windows)
{
    private extern(Windows) void Sleep(uint msec);
}
else version(Posix)
{
    import core.stdc.time;
    import core.sys.posix.time;
    import core.sys.posix.signal;
}

/**
 * Base class for creating threads
 */
class Thread
{
    private void function() func;
    private void delegate() dlgt;
    private bool callFunc;
    private bool initialized = false;

    version(Windows)
    {
        private void* winThread;
    }

    version(Posix)
    {
        private pthread_t posixThread;
        private bool running = false;
    }

    /// Constructor. Initializes Thread using a function pointer
    this(void function() func)
    {
        this.func = func;
        callFunc = true;
    }

    /// Constructor. Initializes Thread using a delegate
    this(void delegate() dlgt)
    {
        this.dlgt = dlgt;
        callFunc = false;
    }

    /// Destructor
    ~this()
    {
        version(Windows)
        {
            if (winThread)
                CloseHandle(winThread);
        }

        version(Posix)
        {
            if (initialized)
                pthread_detach(posixThread);
        }
    }

    /// Starts the thread
    void start()
    {
        version(Windows)
        {
            if (winThread)
                CloseHandle(winThread);
            uint threadId;
            winThread = CreateThread(null, cast(size_t)0, &winThreadFunc, cast(void*)this, cast(uint)0, &threadId);
            assert(winThread !is null);
            initialized = true;
        }

        version(Posix)
        {
            running = true;
            pthread_create(&posixThread, null, &posixThreadFunc, cast(void*)this);
            // TODO: validate thread creation
            initialized = true;
        }
    }

    /// Waits for the thread to terminate
    void join()
    {
        version(Windows)
        {
            WaitForMultipleObjects(1, &winThread, 1, INFINITE);
        }

        version(Posix)
        {
            pthread_join(posixThread, null);
        }
    }

    /// Checks if thread is running
    bool isRunning()
    {
        version(Windows)
        {
            uint c = 0;
            GetExitCodeThread(winThread, &c);
            return (c == STILL_ACTIVE);
        }

        version(Posix)
        {
            return running;
        }
    }

    /// Stops the thread immediately. This functionality is unsafe, use with care
    void terminate()
    {
        version(Windows)
        {
            TerminateThread(winThread, 1);
        }

        version(Posix)
        {
            pthread_cancel(posixThread);
            running = false;
        }
    }

    version(Windows)
    {
        extern(Windows) static uint winThreadFunc(in void* lpParam)
        {
            Thread t = cast(Thread)lpParam;
            if (t.callFunc)
                t.func();
            else
                t.dlgt();
            return 0;
        }
    }

    version(Posix)
    {
        extern(C) static void* posixThreadFunc(void* arg)
        {
            Thread t = cast(Thread)arg;
            if (t.callFunc)
                t.func();
            else
                t.dlgt();
            t.running = false;
            return null;
        }
    }

    /// Wait for specified amout of milliseconds
    static void sleep(uint msec)
    {
        version(Windows)
        {
            Sleep(msec);
        }
        else version(Posix)
        {
            timespec ts;
            ts.tv_sec = msec / 1000;
            ts.tv_nsec = (msec % 1000) * 1000000;
            nanosleep(&ts, null);
        }
    }

    ///
    unittest
    {
        Thread.sleep(100);
        assert(true);
    }
}
